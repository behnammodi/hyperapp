{"id":"pages/Tutorial/tutorial.md","dependencies":[],"generated":{"html":"<p>Welcome! If you&#39;re new to Hyperapp, you&#39;ve found the perfect place to start learning.</p>\n<p>Table of contents</p>\n<ul>\n<li><a href=\"#setup\">The Set-up</a></li>\n<li><a href=\"#helloworld\">Hello World</a></li>\n<li><a href=\"#view\">View</a><ul>\n<li><a href=\"#virtualnodes\">Virtual Nodes</a></li>\n<li><a href=\"#rendertodom\">Rendering to the DOM</a></li>\n<li><a href=\"#composingview\">Composing the view with reusable functions</a></li>\n</ul>\n</li>\n<li><a href=\"#state\">State</a></li>\n<li><a href=\"#actions\">Actions</a><ul>\n<li><a href=\"#reacting\">Reacting to events in the DOM</a></li>\n<li><a href=\"#eventdata\">Capturing event-data in actions</a></li>\n<li><a href=\"#custompayloads\">Actions with custom payloads</a></li>\n<li><a href=\"#payloadfilters\">Payload filters</a></li>\n</ul>\n</li>\n<li><a href=\"#effects\">Effects</a><ul>\n<li><a href=\"#declaringeffects\">Declaring effects in actions</a></li>\n<li><a href=\"#effectfunctions\">Effect functions and <code>dispatch</code></a></li>\n<li><a href=\"#effectsoninit\">Running effects on initialization</a></li>\n<li><a href=\"#effectcreators\">Effect creators</a></li>\n<li><a href=\"#trackingasync\">Tracking state for ansynchronous effects</a></li>\n</ul>\n</li>\n<li><a href=\"#subscriptions\">Subscriptions</a><ul>\n<li><a href=\"#subscriptionfunctions\">Subscription functions</a></li>\n<li><a href=\"#subscribing\">Subscribing</a></li>\n</ul>\n</li>\n<li><a href=\"#conclusion\">Conclusion</a></li>\n</ul>\n<h2 id=\"the-set-up-a-namesetupa\">The Set-up <a name=\"setup\"></a></h2>\n<p>Together we&#39;ll build a simple newsreader-like application. As we do, we&#39;ll work\nour way through the five core concepts: view, state, actions, effects and subscriptions.</p>\n<p>To move things along, let&#39;s imagine we&#39;ve already made a static version of the\napp we want to build, with this HTML:</p>\n<pre><code class=\"language-html\">&lt;div id=&quot;app&quot; class=&quot;container&quot;&gt;\n  &lt;div class=&quot;filter&quot;&gt;\n    Filter:\n    &lt;span class=&quot;filter-word&quot;&gt;ocean&lt;/span&gt;\n    &lt;button&gt;&amp;#9998;&lt;/button&gt;\n  &lt;/div&gt;\n  &lt;div class=&quot;stories&quot;&gt;\n    &lt;ul&gt;\n      &lt;li class=&quot;unread&quot;&gt;\n        &lt;p class=&quot;title&quot;&gt;The &lt;em&gt;Ocean &lt;/em&gt;is Sinking&lt;/p&gt;\n        &lt;p class=&quot;author&quot;&gt;Kat Stropher&lt;/p&gt;\n      &lt;/li&gt;\n      &lt;li class=&quot;reading&quot;&gt;\n        &lt;p class=&quot;title&quot;&gt;&lt;em&gt;Ocean &lt;/em&gt;life is brutal&lt;/p&gt;\n        &lt;p class=&quot;author&quot;&gt;Surphy McBrah&lt;/p&gt;\n      &lt;/li&gt;\n      &lt;li&gt;\n        &lt;p class=&quot;title&quot;&gt;\n          Family friendly fun at the\n          &lt;em&gt;ocean &lt;/em&gt;exhibit\n        &lt;/p&gt;\n        &lt;p class=&quot;author&quot;&gt;Guy Prosales&lt;/p&gt;\n      &lt;/li&gt;\n    &lt;/ul&gt;\n  &lt;/div&gt;\n  &lt;div class=&quot;story&quot;&gt;\n    &lt;h1&gt;Ocean life is brutal&lt;/h1&gt;\n    &lt;p&gt;\n      Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod\n      tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim\n      veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea\n      commodo consequat.\n    &lt;/p&gt;\n    &lt;p class=&quot;signature&quot;&gt;Surphy McBrah&lt;/p&gt;\n  &lt;/div&gt;\n  &lt;div class=&quot;autoupdate&quot;&gt;\n    Auto update:\n    &lt;input type=&quot;checkbox&quot; /&gt;\n  &lt;/div&gt;\n&lt;/div&gt;</code></pre>\n<p>...and some CSS <a href=\"https://hyperapp.dev/tutorial-assets/style.css\">here</a>.</p>\n<p>It looks like this:</p>\n<p><img src=\"https://raw.githubusercontent.com/jorgebucaran/hyperapp/1fd42319051e686adb9819b7e154f764fa3b0d29/docs/src/pages/Tutorial/tut1.png\" alt=\"what it looks like\"></p>\n<p>We&#39;ll start by making Hyperapp render the HTML for us. Then we will\nadd dynamic behavior to all the widgets, including text input and\ndynamically fetching stories.</p>\n<p>First, let&#39;s begin with the traditional &quot;Hello World!&quot;</p>\n<h2 id=\"hello-world-a-namehelloworlda\">Hello World <a name=\"helloworld\"></a></h2>\n<p>Create this html file:</p>\n<pre><code class=\"language-html\">&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;link\n      rel=&quot;stylesheet&quot;\n      href=&quot;https://hyperapp.dev/tutorial-assets/style.css&quot;\n    /&gt;\n    &lt;script type=&quot;module&quot;&gt;\n      import { h, app } from &quot;https://unpkg.com/hyperapp&quot;\n\n      // -- EFFECTS &amp; SUBSCRIPTIONS --\n\n      // -- ACTIONS --\n\n      // -- VIEWS ---\n\n      // -- RUN --\n      app({\n        node: document.getElementById(&quot;app&quot;),\n        view: () =&gt; h(&quot;h1&quot;, {}, [&quot;Hello &quot;, h(&quot;i&quot;, {}, &quot;World!&quot;)]),\n      })\n    &lt;/script&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;\n  &lt;/body&gt;\n&lt;/html&gt;</code></pre>\n<blockquote>\n<p>The section structure outlined in the comments is not important. It&#39;s\njust a suggestion for how to organize the code we&#39;ll be\nadding throughout the tutorial.</p>\n</blockquote>\n<p>Open it in a browser, and you&#39;ll be greeted with an optimistic <strong>Hello <em>World!</em></strong>.</p>\n<h2 id=\"view-a-nameviewa\">View <a name=\"view\"></a></h2>\n<p>Let&#39;s step through what just happened.</p>\n<h3 id=\"virtual-nodes-a-namevirtualnodesa\">Virtual Nodes <a name=\"virtualnodes\"></a></h3>\n<p>Hyperapp exports the <code>app</code> and <code>h</code> functions.\n<code>h</code> is for creating <em>virtual nodes</em>, which is to say: plain javascript objects\nwhich <em>represent</em> DOM nodes.</p>\n<p>The result of</p>\n<pre><code class=\"language-js\">h(&quot;h1&quot;, {}, [&quot;Hello &quot;, h(&quot;i&quot;, {}, &quot;World!&quot;)])</code></pre>\n<p>is a virtual node, representing</p>\n<pre><code class=\"language-html\">&lt;h1&gt;\n  Hello\n  &lt;i&gt;World!&lt;/i&gt;\n&lt;/h1&gt;</code></pre>\n<h3 id=\"rendering-to-the-dom-a-namerendertodoma\">Rendering to the DOM <a name=\"rendertodom\"></a></h3>\n<p><code>app</code> is the function that runs our app. It is called with a single argument - an object\nwhich can take several properties. For now we&#39;re just concerned with <code>view</code> and <code>node.</code></p>\n<p>Hyperapp calls the <code>view</code> function which tells it the DOM structure we want, in the form\nof virtual nodes. Hyperapp proceeds to create it for us, replacing the node specified in <code>node</code>.</p>\n<p>To render the HTML we want, change the <code>view</code> to:</p>\n<pre><code class=\"language-js\">view: () =&gt; h(&quot;div&quot;, {id: &quot;app&quot;, class: &quot;container&quot;}, [\n  h(&quot;div&quot;, {class: &quot;filter&quot;}, [\n    &quot; Filter: &quot;,\n    h(&quot;span&quot;, {class: &quot;filter-word&quot;}, &quot;ocean&quot;),\n    h(&quot;button&quot;, {}, &quot;\\u270E&quot;)\n  ]),\n  h(&quot;div&quot;, {class: &quot;stories&quot;}, [\n    h(&quot;ul&quot;, {}, [\n      h(&quot;li&quot;, {class: &quot;unread&quot;}, [\n        h(&quot;p&quot;, {class: &quot;title&quot;}, [\n          &quot;The &quot;,\n          h(&quot;em&quot;, {}, &quot;Ocean&quot;),\n          &quot; is Sinking!&quot;\n        ]),\n        h(&quot;p&quot;, {class: &quot;author&quot;}, &quot;Kat Stropher&quot;)\n      ]),\n      h(&quot;li&quot;, {class: &quot;reading&quot;}, [\n        h(&quot;p&quot;, {class: &quot;title&quot;}, [\n          h(&quot;em&quot;, {}, &quot;Ocean&quot;),\n          &quot; life is brutal&quot;\n        ]),\n        h(&quot;p&quot;, {class: &quot;author&quot;}, &quot;Surphy McBrah&quot;),\n      ]),\n      h(&quot;li&quot;, {}, [\n        h(&quot;p&quot;, {class: &quot;title&quot;}, [\n          &quot;Family friendly fun at the &quot;,\n          h(&quot;em&quot;, {}, &quot;ocean&quot;),\n          &quot; exhibit&quot;\n        ]),\n        h(&quot;p&quot;, {class: &quot;author&quot;}, &quot;Guy Prosales&quot;)\n      ])\n    ])\n  ]),\n  h(&quot;div&quot;, {class: &quot;story&quot;}, [\n    h(&quot;h1&quot;, {}, &quot;Ocean life is brutal&quot;),\n    h(&quot;p&quot;, {}, `\n      Lorem ipsum dolor sit amet, consectetur adipiscing\n      elit, sed do eiusmod tempor incididunt ut labore et\n      dolore magna aliqua. Ut enim ad minim veniam, quis\n      nostrud exercitation ullamco laboris nisi ut aliquip\n      ex ea commodo consequat.\n    `),\n    h(&quot;p&quot;, {class: &quot;signature&quot;}, &quot;Surphy McBrah&quot;)\n  ]),\n  h(&quot;div&quot;, {class: &quot;autoupdate&quot;}, [\n    &quot;Auto update: &quot;,\n    h(&quot;input&quot;, {type: &quot;checkbox&quot;})\n  ])\n]),</code></pre>\n<p>Try it out to confirm that the result matches the screenshot above.</p>\n<blockquote>\n<p>In many frameworks it is common to write your views/templates\nusing syntax that looks like HTML. This is possible with Hyperapp as well.\n<a href=\"https://babeljs.io/docs/en/babel-plugin-transform-react-jsx\">JSX</a>\ncan compile a HTML-like syntax into <code>h</code> calls at build-time. If you&#39;d rather\nnot use a build system, <a href=\"https://github.com/developit/htm\">htm</a> does the same at run-time.</p>\n<p>In this tutorial we&#39;ll stick with <code>h</code> to keep it simple and close to the metal.</p>\n</blockquote>\n<h3 id=\"composing-the-view-with-reusable-functions-a-namecomposingviewa\">Composing the view with reusable functions <a name=\"composingview\"></a></h3>\n<p>The great thing about using plain functions to build up our virtual DOM\nis that we can break out repetitive or complicated parts into their own functions.</p>\n<p>Add this function (in the &quot;VIEWS&quot; section):</p>\n<pre><code class=\"language-js\">const emphasize = (word, string) =&gt;\n  string.split(&quot; &quot;).map(x =&gt; {\n    if (x.toLowerCase() === word.toLowerCase()) {\n      return h(&quot;em&quot;, {}, x + &quot; &quot;)\n    } else {\n      return x + &quot; &quot;\n    }\n  })</code></pre>\n<p>It lets you change this:</p>\n<pre><code class=\"language-js\">  ...\n  h(&quot;p&quot;, {class: &quot;title&quot;}, [\n    &quot;The &quot;,\n    h(&quot;em&quot;, {}, &quot;Ocean&quot;),\n    &quot; is Sinking!&quot;\n  ]),\n  ...</code></pre>\n<p>into this:</p>\n<pre><code class=\"language-js\">  ...\n  h(&quot;p&quot;, {class: &quot;title&quot;}, emphasize(&quot;ocean&quot;,\n    &quot;The Ocean is Sinking&quot;\n  ))\n  ...</code></pre>\n<p>Story thumbnails are repeated several times, so encapsulate\nthem in their own function:</p>\n<pre><code class=\"language-js\">const storyThumbnail = props =&gt;\n  h(\n    &quot;li&quot;,\n    {\n      class: {\n        unread: props.unread,\n        reading: props.reading,\n      },\n    },\n    [\n      h(&quot;p&quot;, { class: &quot;title&quot; }, emphasize(props.filter, props.title)),\n      h(&quot;p&quot;, { class: &quot;author&quot; }, props.author),\n    ]\n  )</code></pre>\n<blockquote>\n<p>The last example demonstrates a helpful feature of the <code>class</code> property. When\nyou set it to an object rather than a string, each key with a truthy value\nwill become a class in the class list.</p>\n</blockquote>\n<p>Continue by creating functions for each section of the view:</p>\n<pre><code class=\"language-js\">const storyList = props =&gt;\n  h(&quot;div&quot;, { class: &quot;stories&quot; }, [\n    h(\n      &quot;ul&quot;,\n      {},\n      Object.keys(props.stories).map(id =&gt;\n        storyThumbnail({\n          id,\n          title: props.stories[id].title,\n          author: props.stories[id].author,\n          unread: !props.stories[id].seen,\n          reading: props.reading === id,\n          filter: props.filter,\n        })\n      )\n    ),\n  ])\n\nconst filterView = props =&gt;\n  h(&quot;div&quot;, { class: &quot;filter&quot; }, [\n    &quot;Filter:&quot;,\n    h(&quot;span&quot;, { class: &quot;filter-word&quot; }, props.filter),\n    h(&quot;button&quot;, {}, &quot;\\u270E&quot;),\n  ])\n\nconst storyDetail = props =&gt;\n  h(&quot;div&quot;, { class: &quot;story&quot; }, [\n    props &amp;&amp; h(&quot;h1&quot;, {}, props.title),\n    props &amp;&amp;\n      h(\n        &quot;p&quot;,\n        {},\n        `\n    Lorem ipsum dolor sit amet, consectetur adipiscing\n    elit, sed do eiusmod tempor incididunt ut labore et\n    dolore magna aliqua. Ut enim ad minim veniam, qui\n    nostrud exercitation ullamco laboris nisi ut aliquip\n    ex ea commodo consequat.\n  `\n      ),\n    props &amp;&amp; h(&quot;p&quot;, { class: &quot;signature&quot; }, props.author),\n  ])\n\nconst autoUpdateView = props =&gt;\n  h(&quot;div&quot;, { class: &quot;autoupdate&quot; }, [\n    &quot;Auto update: &quot;,\n    h(&quot;input&quot;, { type: &quot;checkbox&quot; }),\n  ])\n\nconst container = content =&gt; h(&quot;div&quot;, { class: &quot;container&quot; }, content)</code></pre>\n<p>With those the view can be written as:</p>\n<pre><code class=\"language-js\">view: () =&gt;\n  container([\n    filterView({\n      filter: &quot;ocean&quot;,\n    }),\n    storyList({\n      stories: {\n        &quot;112&quot;: {\n          title: &quot;The Ocean is Sinking&quot;,\n          author: &quot;Kat Stropher&quot;,\n          seen: false,\n        },\n        &quot;113&quot;: {\n          title: &quot;Ocean life is brutal&quot;,\n          author: &quot;Surphy McBrah&quot;,\n          seen: true,\n        },\n        &quot;114&quot;: {\n          title: &quot;Family friendly fun at the ocean exhibit&quot;,\n          author: &quot;Guy Prosales&quot;,\n          seen: true,\n        },\n      },\n      reading: &quot;113&quot;,\n      filter: &quot;ocean&quot;,\n    }),\n    storyDetail({\n      title: &quot;Ocean life is brutal&quot;,\n      author: &quot;Surphy McBrah&quot;,\n    }),\n    autoUpdateView(),\n  ])</code></pre>\n<p>What you see on the page should be exactly the same as before, because we haven&#39;t\nchanged what <code>view</code> returns. Using basic functional composition, we were able to make\nthe code a bit more manageable, and that&#39;s the only difference.</p>\n<h2 id=\"state-a-namestatea\">State <a name=\"state\"></a></h2>\n<p>With all that view logic broken out in separate functions, <code>view</code> is starting to look like\nplain <em>data</em>. The next step is to fully separate data from the view.</p>\n<p>Add an <code>init</code> property to your app, with this pure data:</p>\n<pre><code class=\"language-js\">  init: {\n    filter: &quot;ocean&quot;,\n    reading: &quot;113&quot;,\n    stories: {\n      &quot;112&quot;: {\n        title: &quot;The Ocean is Sinking&quot;,\n        author: &quot;Kat Stropher&quot;,\n        seen: false,\n      },\n      &quot;113&quot;: {\n        title: &quot;Ocean life is brutal&quot;,\n        author: &quot;Surphy McBrah&quot;,\n        seen: true,\n      },\n      &quot;114&quot;: {\n        title: &quot;Family friendly fun at the ocean exhibit&quot;,\n        author: &quot;Guy Prosales&quot;,\n        seen: true,\n      }\n    }\n  },</code></pre>\n<p>The value of <code>init</code> becomes the app&#39;s <em>state</em>. Hyperapp calls <code>view</code> with the state\nas an argument, so it can be reduced to:</p>\n<pre><code class=\"language-js\">  view: state =&gt; container([\n    filterView(state),\n    storyList(state),\n    storyDetail(state.reading &amp;&amp; state.stories[state.reading]),\n    autoUpdateView(state),\n  ]),</code></pre>\n<p>Visually, everything is <em>still</em> the same. If you&#39;d like to see a working example of the code so far, have a look <a href=\"https://codesandbox.io/s/hyperapp-tutorial-step-1-gq662\">here</a></p>\n<h2 id=\"actions-a-nameactionsa\">Actions <a name=\"actions\"></a></h2>\n<p>Now that we know all about rendering views, it&#39;s finally time for some <em>action</em>!</p>\n<h3 id=\"reacting-to-events-in-the-dom-a-namereactinga\">Reacting to events in the DOM <a name=\"reacting\"></a></h3>\n<p>The first bit of dynamic behavior we will add is so that when you click\nthe pencil-button, a text input with the filter word appears.</p>\n<p>Add an <code>onclick</code> property to the button in <code>filterView</code>:</p>\n<pre><code class=\"language-js\">const filterView = props =&gt;\n  h(&quot;div&quot;, { class: &quot;filter&quot; }, [\n    &quot;Filter:&quot;,\n    h(&quot;span&quot;, { class: &quot;filter-word&quot; }, props.filter),\n    h(&quot;button&quot;, { onclick: StartEditingFilter }, &quot;\\u270E&quot;), // &lt;---\n  ])</code></pre>\n<p>This makes Hyperapp bind a click-event handler on the button element, so\nthat when the button is clicked, an action named <code>StartEditingFilter</code> is\n<em>dispatched</em>. Create the action in the &quot;ACTIONS&quot; section:</p>\n<pre><code class=\"language-js\">const StartEditingFilter = state =&gt; ({ ...state, editingFilter: true })</code></pre>\n<p>Actions are just functions describing transformations of the state.\nThis action keeps everything in the state the same except for <code>editingFilter</code>\nwhich it sets to <code>true</code>.</p>\n<p>When Hyperapp dispatches an action, it replaces the old state with the new\none calculated using the action. Then the DOM is modified to match what the\nview returns for this new state.</p>\n<p>When <code>editingFilter</code> is true, we want to have a text input instead of a\nspan with the filter word. We can express this in <code>filterView</code> using a\nternary operator (<code>a ? b : c</code>).</p>\n<pre><code class=\"language-js\">const filterView = props =&gt;\n  h(&quot;div&quot;, { class: &quot;filter&quot; }, [\n    &quot;Filter:&quot;,\n\n    props.editingFilter // &lt;---\n      ? h(&quot;input&quot;, { type: &quot;text&quot;, value: props.filter }) // &lt;---\n      : h(&quot;span&quot;, { class: &quot;filter-word&quot; }, props.filter),\n\n    h(&quot;button&quot;, { onclick: StartEditingFilter }, &quot;\\u270E&quot;),\n  ])</code></pre>\n<p>Now, when you click the pencil button the text input appears. But we still need to add\na way to go back. We need an action to <code>StopEditingFilter</code>, and a button to dispatch it.</p>\n<p>Add the action:</p>\n<pre><code class=\"language-js\">const StopEditingFilter = state =&gt; ({ ...state, editingFilter: false })</code></pre>\n<p>and update <code>filterView</code> again:</p>\n<pre><code class=\"language-js\">const filterView = props =&gt;\n  h(&quot;div&quot;, { class: &quot;filter&quot; }, [\n    &quot;Filter:&quot;,\n\n    props.editingFilter\n      ? h(&quot;input&quot;, { type: &quot;text&quot;, value: props.filter })\n      : h(&quot;span&quot;, { class: &quot;filter-word&quot; }, props.filter),\n\n    props.editingFilter // &lt;---\n      ? h(&quot;button&quot;, { onclick: StopEditingFilter }, &quot;\\u2713&quot;)\n      : h(&quot;button&quot;, { onclick: StartEditingFilter }, &quot;\\u270E&quot;), // &lt;---\n  ])</code></pre>\n<p>When you click the pencil button, it is replaced with a check-mark button that can take you back to the first state.</p>\n<p><img src=\"https://raw.githubusercontent.com/jorgebucaran/hyperapp/1fd42319051e686adb9819b7e154f764fa3b0d29/docs/src/pages/Tutorial/tut2.png\" alt=\"editing filter word\"></p>\n<h3 id=\"capturing-event-data-in-actions-a-nameeventdataa\">Capturing event-data in actions <a name=\"eventdata\"></a></h3>\n<p>The next step is to use the input for editing the filter word. Whatever we\ntype in the box should be emphasized in the story-list.</p>\n<p>Update <code>filterView</code> yet again:</p>\n<pre><code class=\"language-js\">const filterView = props =&gt;\n  h(&quot;div&quot;, { class: &quot;filter&quot; }, [\n    &quot;Filter:&quot;,\n\n    props.editingFilter\n      ? h(&quot;input&quot;, {\n          type: &quot;text&quot;,\n          value: props.filter,\n          oninput: SetFilter, // &lt;----\n        })\n      : h(&quot;span&quot;, { class: &quot;filter-word&quot; }, props.filter),\n\n    props.editingFilter\n      ? h(&quot;button&quot;, { onclick: StopEditingFilter }, &quot;\\u2713&quot;)\n      : h(&quot;button&quot;, { onclick: StartEditingFilter }, &quot;\\u270E&quot;),\n  ])</code></pre>\n<p>This will dispatch the <code>SetFilter</code> action everytime someone types in the input. Implement the action like this:</p>\n<pre><code class=\"language-js\">const SetFilter = (state, event) =&gt; ({ ...state, filter: event.target.value })</code></pre>\n<p>The second argument to an action is known as the <em>payload</em>. Actions\ndispatched in response to an events on DOM elements receive the <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Event\">event object</a> for a payload. <code>event.target</code> refers to the input element in the DOM, and\n<code>event.target.value</code> refers to the current value entered into it.</p>\n<p>Now see what happens when you erase &quot;ocean&quot; and type &quot;friendly&quot; instead:</p>\n<p><img src=\"https://raw.githubusercontent.com/jorgebucaran/hyperapp/1fd42319051e686adb9819b7e154f764fa3b0d29/docs/src/pages/Tutorial/tut3.png\" alt=\"typed friendly in filter\"></p>\n<h3 id=\"actions-with-custom-payloads-a-namecustompayloadsa\">Actions with custom payloads <a name=\"custompayloads\"></a></h3>\n<p>Next up: selecting stories by clicking them in the list.</p>\n<p>The following action sets the <code>reading</code> property in the state to a story-id, which amounts to &quot;selecting&quot; the story:</p>\n<pre><code class=\"language-js\">const SelectStory = (state, id) =&gt; ({ ...state, reading: id })</code></pre>\n<p>It has a payload, but it&#39;s not an event object. It&#39;s a custom value telling us which\nstory was clicked. How are actions dispatched with custom payloads? – Like this:</p>\n<pre><code class=\"language-js\">const storyThumbnail = props =&gt;\n  h(\n    &quot;li&quot;,\n    {\n      onclick: [SelectStory, props.id], // &lt;----\n      class: {\n        unread: props.unread,\n        reading: props.reading,\n      },\n    },\n    [\n      h(&quot;p&quot;, { class: &quot;title&quot; }, emphasize(props.filter, props.title)),\n      h(&quot;p&quot;, { class: &quot;author&quot; }, props.author),\n    ]\n  )</code></pre>\n<p>Instead of just specifying the action, we give a length-2 array with the action first and the custom payload second.</p>\n<p>Selecting stories works now, but the feature is not quite done. When a story is selected,\nwe need to set its <code>seen</code> property to <code>true</code>, so we can highlight which stories the user has yet to read. Update the <code>SelectStory</code> action:</p>\n<pre><code class=\"language-js\">const SelectStory = (state, id) =&gt; ({\n  ...state, // keep all state the same, except for the following:\n  reading: id,\n  stories: {\n    ...state.stories, //keep stories the same, except for:\n    [id]: {\n      ...state.stories[id], //keep this story the same, except for:\n      seen: true,\n    },\n  },\n})</code></pre>\n<p>Now, when you select a blue-edged story it turns yellow because it is selected, and when you select something else,\nthe edge turns gray to indicate you&#39;ve read the story.</p>\n<p><img src=\"https://raw.githubusercontent.com/jorgebucaran/hyperapp/1fd42319051e686adb9819b7e154f764fa3b0d29/docs/src/pages/Tutorial/tut4.png\" alt=\"read stories are gray\"></p>\n<h3 id=\"payload-filters-a-namepayloadfiltersa\">Payload filters <a name=\"payloadfilters\"></a></h3>\n<p>There&#39;s one little thing we should fix about <code>SetFilter</code>. See how it&#39;s dependent on the complex <code>event</code> object?\nIt would be easier to test and reuse if it were simply:</p>\n<pre><code class=\"language-js\">const SetFilter = (state, word) =&gt; ({ ...state, filter: word })</code></pre>\n<p>But we don&#39;t know the word beforehand, so how can we set it as a custom payload? Change the <code>Filter</code> view\nagain (last time - I promise!):</p>\n<pre><code class=\"language-js\">const filterView = props =&gt;\n  h(&quot;div&quot;, { class: &quot;filter&quot; }, [\n    &quot;Filter:&quot;,\n\n    props.editingFilter\n      ? h(&quot;input&quot;, {\n          type: &quot;text&quot;,\n          value: props.filter,\n          oninput: [SetFilter, event =&gt; event.target.value], // &lt;----\n        })\n      : h(&quot;span&quot;, { class: &quot;filter-word&quot; }, props.filter),\n\n    props.editingFilter\n      ? h(&quot;button&quot;, { onclick: StopEditingFilter }, &quot;\\u2713&quot;)\n      : h(&quot;button&quot;, { onclick: StartEditingFilter }, &quot;\\u270E&quot;),\n  ])</code></pre>\n<p>When we give a <em>function</em> as the custom payload, Hyperapp considers it a <em>payload filter</em> and passes the default\npayload through it, providing the returned value as payload to the action.</p>\n<blockquote>\n<p>Payload filters are also useful when you need a payload that is a combination of custom data and event data</p>\n</blockquote>\n<p>If you&#39;d like to see a working example of the code so far, have a look <a href=\"https://codesandbox.io/s/hyperapp-tutorial-step-2-5yv34\">here</a></p>\n<h2 id=\"effects-a-nameeffectsa\">Effects <a name=\"effects\"></a></h2>\n<p>So far, the list of stories has been defined in the state and doesn&#39;t change. What we really want is\nwhen we&#39;re done changing the filter-word, stories matching it should be loaded.</p>\n<p>Before looking at how we make the request for new stories, one thing is for sure: when new stories\ncome back they need to go into the state, and the only way to modify the state is through an action.\nSo we&#39;re definitely going to need the following action:</p>\n<pre><code class=\"language-js\">const GotStories = (state, stories) =&gt; ({\n  ...state,\n\n  // replace old stories with new,\n  // but keep the &#39;seen&#39; value if it exists\n  stories: Object.keys(stories)\n    .map(id =&gt; [\n      id,\n      {\n        ...stories[id],\n        seen: state.stories[id] &amp;&amp; state.stories[id].seen,\n      },\n    ])\n    .reduce((o, [id, story]) =&gt; ((o[id] = story), o), {}),\n\n  // in case the current story is in the new list as well,\n  // keep it selected, Otherwise select nothing\n  reading: stories[state.reading] ? state.reading : null,\n})</code></pre>\n<h3 id=\"declaring-effects-in-actions-a-namedeclaringeffectsa\">Declaring effects in actions <a name=\"declaringeffects\"></a></h3>\n<p>Our request for new stories should go out once we&#39;re done editing the filter, which is to say: when we click\nthe check-mark button and <code>StopEditingFilter</code> is dispatched. When an action needs to do something\nbesides transforming the state, that &quot;something&quot; is called an <em>effect</em>. To associate an effect\nwith <code>StopEditingFilter</code>, make it return an array like this:</p>\n<pre><code class=\"language-js\">const StopEditingFilter = state =&gt; [\n  {\n    ...state,\n    editingFilter: false,\n  },\n\n  // effect declarations go here: //\n]</code></pre>\n<p>When an action returns an array, Hyperapp understands that the first item is the new state we want, and\nthe rest are <em>effect declarations</em>. Hyperapp takes care of running all declared effects once the state\nhas been updated.</p>\n<p>Add this effect declaration:</p>\n<pre><code class=\"language-js\">const StopEditingFilter = state =&gt; [\n  {\n    ...state,\n    editingFilter: false,\n  },\n\n  // effect declarations go here: //\n  [\n    fetchJSONData,\n    {\n      url: `https://hyperapp.dev/tutorial-assets/stories/${state.filter.toLowerCase()}.json`,\n      onresponse: GotStories,\n    },\n  ],\n]</code></pre>\n<p>The first item in an effect declaration – here <code>fetchJSONData</code> – is the\n<em>effect function</em> that we want Hyperapp to call. The second item contains\nthe options we want passed to effect function when it&#39;s called. Here, we are\ntelling <code>fetchJSONData</code> where the stories for the current filter are, and\nto dispatch them as payload to <code>GotStories</code>, on response.</p>\n<h3 id=\"effect-functions-and-dispatch-a-nameeffectfunctionsa\">Effect functions and <code>dispatch</code> <a name=\"effectfunctions\"></a></h3>\n<p>Now we just need to implement <code>fetchJSONData</code>. Type this in the &quot;EFFECTS &amp; SUBSCRIPTIONS&quot; section:</p>\n<pre><code class=\"language-js\">const fetchJSONData = (dispatch, options) =&gt;\n  fetch(options.url)\n    .then(response =&gt; response.json())\n    .then(data =&gt; dispatch(options.onresponse, data))\n    .catch(() =&gt; dispatch(options.onresponse, {}))</code></pre>\n<blockquote>\n<p>It&#39;s a good practice to write your effect functions generically like this, rather than\nhardcoding options. That way it can be used for multiple situations, even by others\nif you chose to publish it.</p>\n<p>...speaking of which: make sure to check out the available effects published by members of the\nHyperapp community, and perhaps save yourself some trouble implementing everything yourself.</p>\n</blockquote>\n<p>When Hyperapp calls an effect function, it passes the <code>dispatch</code> function to it as the first\nargument. <code>dispatch</code> is how effect functions are able to &quot;report back&quot; to the app, by dispatching\nactions (first argument) with payloads (second argument)</p>\n<p>Now, go ahead and try it out! Enter &quot;life&quot; in the filter input. When you click the check-mark button some new\nstories are loaded – all with blue edges except for &quot;Ocean life is brutal&quot; because it is\nstill selected.</p>\n<p><img src=\"https://raw.githubusercontent.com/jorgebucaran/hyperapp/1fd42319051e686adb9819b7e154f764fa3b0d29/docs/src/pages/Tutorial/tut5.png\" alt=\"fetched life stories\"></p>\n<h3 id=\"running-effects-on-initialization-a-nameeffectsoninita\">Running effects on initialization <a name=\"effectsoninit\"></a></h3>\n<p>The next obvious step is to load the <em>initial</em> stories from the API as well. Change init to this:</p>\n<pre><code class=\"language-js\">  init: [\n    {\n      editingFilter: false,\n      autoUpdate: false,\n      filter: &quot;ocean&quot;,\n      reading: null,\n      stories: {},                                                       // &lt;---\n    },\n    [                                                                    // &lt;---\n      fetchJSONData,                                                     // &lt;---\n      {                                                                  // &lt;---\n        url: `https://hyperapp.dev/tutorial-assets/stories/ocean.json`,  // &lt;---\n        onresponse: GotStories                                           // &lt;---\n      }                                                                  // &lt;---\n    ]                                                                    // &lt;---\n  ],</code></pre>\n<p>The point here is that init works just like the return value of an action, including\ncalling effects when it is given as an array. If you reload the page you&#39;ll see\n(after a moment) that all the same stories appear, despite them not existing in\nthe state initially.</p>\n<p><img src=\"https://raw.githubusercontent.com/jorgebucaran/hyperapp/1fd42319051e686adb9819b7e154f764fa3b0d29/docs/src/pages/Tutorial/tut6.png\" alt=\"fresh stories on init\"></p>\n<h3 id=\"effect-creators-a-nameeffectcreatorsa\">Effect creators <a name=\"effectcreators\"></a></h3>\n<p>However, repeating the effect declaration in all its gory detail like this\nis not ideal, so lets add this <em>effect creator</em></p>\n<pre><code class=\"language-js\">const storyLoader = searchWord =&gt; [\n  fetchJSONData,\n  {\n    url: `https://hyperapp.dev/tutorial-assets/stories/${searchWord.toLowerCase()}.json`,\n    onresponse: GotStories,\n  },\n]</code></pre>\n<p>Now we can simplify <code>StopEditingFilter</code> like this:</p>\n<pre><code class=\"language-js\">const StopEditingFilter = state =&gt; [\n  {\n    ...state,\n    editingFilter: false,\n  },\n  storyLoader(state.filter),\n]</code></pre>\n<p>... and <code>init:</code> like this:</p>\n<pre><code class=\"language-js\">  init: [\n    {\n      editingFilter: false,\n      autoUpdate: false,\n      filter: &quot;ocean&quot;,\n      reading: null,\n      stories: {},\n    },\n    storyLoader(&quot;ocean&quot;)\n  ],</code></pre>\n<h3 id=\"tracking-state-for-asynchronous-effects-a-nametrackingasynca\">Tracking state for asynchronous effects <a name=\"trackingasync\"></a></h3>\n<p>If we could display a spinner while we wait for stories to load, it would make for a smoother user experience. We&#39;ll need a state property to tell us wether or not we&#39;re currently <code>fetching</code>, and we&#39;ll use this action to keep track of it:</p>\n<pre><code class=\"language-js\">const SetFetching = (state, fetching) =&gt; ({ ...state, fetching })</code></pre>\n<p>Update <code>storyLoader</code> to tell <code>fetchJSONData</code> about <code>SetFetching</code></p>\n<pre><code class=\"language-js\">const storyLoader = searchWord =&gt; [\n  fetchJSONData,\n  {\n    url: `https://hyperapp.dev/tutorial-assets/stories/${searchWord.toLowerCase()}.json`,\n    onresponse: GotStories,\n    onstart: [SetFetching, true], // &lt;----\n    onfinish: [SetFetching, false], // &lt;----\n  },\n]</code></pre>\n<p>Finally update <code>fetchJSONData</code> to use the new <code>onstart</code> and <code>onfinish</code> options to notify when fetches start and end:</p>\n<pre><code class=\"language-js\">const fetchJSONData = (dispatch, options) =&gt; {\n  dispatch(options.onstart) // &lt;---\n  fetch(options.url)\n    .then(response =&gt; response.json())\n    .then(data =&gt; dispatch(options.onresponse, data))\n    .catch(() =&gt; dispatch(options.onresponse, {}))\n    .finally(() =&gt; dispatch(options.onfinish)) // &lt;---\n}</code></pre>\n<p>With that, our state prop <code>fetching</code> will always tell us wether or not we are fetching.\nUse that to show a spinner when we are fetching, in <code>storyList</code>:</p>\n<pre><code class=\"language-js\">const storyList = props =&gt;\n  h(&quot;div&quot;, { class: &quot;stories&quot; }, [\n    // show spinner overlay if fetching\n    props.fetching &amp;&amp;\n      h(&quot;div&quot;, { class: &quot;loadscreen&quot; }, [h(&quot;div&quot;, { class: &quot;spinner&quot; })]),\n\n    h(\n      &quot;ul&quot;,\n      {},\n      Object.keys(props.stories).map(id =&gt;\n        storyThumbnail({\n          id,\n          title: props.stories[id].title,\n          author: props.stories[id].author,\n          unread: !props.stories[id].seen,\n          reading: props.reading === id,\n          filter: props.filter,\n        })\n      )\n    ),\n  ])</code></pre>\n<p>When the app loads, and when you change the filter, you should see the spinner appear until the stories are loaded.</p>\n<p><img src=\"https://raw.githubusercontent.com/jorgebucaran/hyperapp/1fd42319051e686adb9819b7e154f764fa3b0d29/docs/src/pages/Tutorial/tut7.png\" alt=\"spinner\"></p>\n<blockquote>\n<p>If you aren&#39;t seeing the spinner, it might just be happening too fast. Try choking your network speed. In the Chrome\nbrowser you can set your network speed to &quot;slow 3g&quot; under the network tab in the developer tools.</p>\n</blockquote>\n<p>If you&#39;d like to see a working example of the code so far, have a look <a href=\"https://codesandbox.io/s/hyperapp-tutorial-step-3-2mmug\">here</a></p>\n<h2 id=\"subscriptions-a-namesubscriptionsa\">Subscriptions <a name=\"subscriptions\"></a></h2>\n<p>The last feature we&#39;ll add is one where the user can opt in to have the app check every five seconds for new\nstories matching the current filter. (There won&#39;t actually be any new stories, because it&#39;s not a real service,\nbut you&#39;ll know it&#39;s happening when you see the spinner pop up every five seconds.)</p>\n<p>First let&#39;s keep track of wether or not the user wants this auto-update feature on. Create a new action:</p>\n<pre><code class=\"language-js\">const ToggleAutoUpdate = state =&gt; ({ ...state, autoUpdate: !state.autoUpdate })</code></pre>\n<p>Dispatch it in response to checking the checkbox in <code>autoUpdateView</code>:</p>\n<pre><code class=\"language-js\">const autoUpdateView = props =&gt;\n  h(&quot;div&quot;, { class: &quot;autoupdate&quot; }, [\n    &quot;Auto update: &quot;,\n    h(&quot;input&quot;, {\n      type: &quot;checkbox&quot;,\n      checked: props.autoUpdate, // &lt;---\n      oninput: ToggleAutoUpdate, // &lt;---\n    }),\n  ])</code></pre>\n<p>With that, the state property <code>autoUpdate</code> will tell us wether or not the Auto-update checkbox is checked.</p>\n<h3 id=\"subscription-functions-a-namesubscriptionfunctionsa\">Subscription functions <a name=\"subscriptionfunctions\"></a></h3>\n<p>We need a <em>subscription function</em> capable of dispatching actions at a given interval. Implement\n<code>intervalSubscription</code> in the &quot;EFFECTS &amp; SUBSCRIPTIONS&quot; section:</p>\n<pre><code class=\"language-js\">const intervalSubscription = (dispatch, options) =&gt; {\n  const interval = setInterval(() =&gt; dispatch(options.action), options.time)\n  return () =&gt; clearInterval(interval)\n}</code></pre>\n<p>Just like an effect function, this function will be called by Hyperapp with <code>dispatch</code> and given options. It\nwill start an interval listener, and every <code>options.time</code> milliseconds, it will dispatch the given action. The\nmain difference to an effect function is that a subscription function returns a function so hyperapp knows\nhow to stop the subscription.</p>\n<blockquote>\n<p>As with effects, you may find a suitable subscription already published\nin the Hyperapp community.</p>\n</blockquote>\n<h3 id=\"subscribing-a-namesubscribinga\">Subscribing <a name=\"subscribing\"></a></h3>\n<p>We could create a new action for updating stories, but since <code>StopEditingFilter</code> already does what we want, we&#39;ll\nuse it here too. Add a <code>subscription</code> property to the app:</p>\n<pre><code class=\"language-js\">subscriptions: state =&gt; [\n  state.autoUpdate &amp;&amp;\n    !state.editingFilter &amp;&amp; [\n      intervalSubscription,\n      {\n        time: 5000, //milliseconds,\n        action: StopEditingFilter,\n      },\n    ],\n]</code></pre>\n<p>Just like for <code>view</code>, hyperapp will run <code>subscriptions</code> with the new state every time it changes, to get\na list of subscription-declarations that should be active. In our case, whenever the Auto Update checkbox is\nchecked and we are <em>not</em> busy editing the filter, our interval subscription will be active.</p>\n<p><img src=\"https://raw.githubusercontent.com/jorgebucaran/hyperapp/1fd42319051e686adb9819b7e154f764fa3b0d29/docs/src/pages/Tutorial/tut8.png\" alt=\"auto update\"></p>\n<p>Hyperapp will only stop or start subscriptions when the declaration changes\nfrom one state to the next. Subscriptions are <em>not</em> stopped and started <em>every</em> time the state changes.</p>\n<p>If you&#39;d like to see a working example of the final code, have a look <a href=\"https://codesandbox.io/s/hyperapp-tutorial-step-4-8u9q8\">here</a></p>\n<h2 id=\"conclusion-a-nameconclusiona\">Conclusion <a name=\"conclusion\"></a></h2>\n<p>Congratulations on completing this Hyperapp tutorial!</p>\n<p>Along the way you&#39;ve familiarized yourself with\nthe core concepts: <em>view</em>, <em>state</em>, <em>actions</em>, <em>effects</em> &amp; <em>subscriptions</em>. And that&#39;s really all you need to\nbuild any web application.</p>\n"},"sourceMaps":null,"error":null,"hash":"cc5801453a0d12c8e48e424c13340ef3","cacheData":{}}